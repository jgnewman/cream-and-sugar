###
New Syntax
###

up() ->
  spawn fn ->

    # Define the factorial function so that we can actually calculate them.
    factorial 0 -> 1
    factorial n -> n * factorial n - 1

    # When we receive a message, pattern match it to figure out what to do.
    receive
      match {{ FACTORIAL, num }} -> reply {{ OK, factorial num }}
      match _                    -> {{ ERR, 'Unknown' }}


-----------------

The form `identifier_` is reserved for system variables.

All functions compile with the following first line of the body:

  const scope_ = {};

Function definitions take one of these forms...

  FUNCTIONCALL -> FUNCTIONBODY

    const factorial_ = {
      name: 'factorial',
      0: [
           [ [], function () { return 1 } ]
         ],
      1: [
           [ [CNS_._], function (n) { return n * factorial(n - 1) }] ]
         ]
    };

    const factorial = function () {
      return CNS_.patternMatch(this, factorial_, arguments);
    }

  FN -> FUNCTIONBODY

    function () { ... }

  (MATCH PARAMS -> FUNCTIONBODY) * n

    // assuming something like `factorial = [INDENT] match ...`
    function () {
      const _ = {
        name: 'anonymous',
        0: [
             [ [], function () { return 1 } ]
           ],
        1: [
             [ [CNS_._], function (n) { return n * factorial(n - 1) }] ]
           ]
      };
      return CNS_.patternMatch(this, _, arguments);
    }

Requiring, of course, the following lib...

  CNS_._ = {};

  CNS_.arityErr = function (name, ar) {
    throw new Error("Function " + name + " does not allow arity " + ar);
  };

  CNS_.matchErr = function (name) {
    throw new Error("Unable to find pattern match for function " + name);
  };

  CNS_.patternMatch = function (ctx, map, argu) {
    var args = Array.prototype.slice.call(argu);
    var arity = map[args.length];
    var out;
    if (!arity) return CNS_.arityErr(map.name, args.length);
    arity.some(function (match) {
      if (CNS_.isMatch(match[0], args)) { // the pattern
        out = match[1]; // the function
        return true;
      }
      return false;
    });
    return !out ? CNS_.matchErr(map.name) : out.apply(ctx, args);
  };

  CNS_.isMatch = function (pat, args) {
    // Note, pat and args will always be the same length as long as
    // this function is only called from `patternMatch`.
    var isMatch = true;
    pat.every(function (patItem, index) {
      return (isMatch = CNS_.deepEql(patItem, args[index]));
    });
    return isMatch;
  };

  CNS_.deepEql = function (x, y) {
    // get inspiration from the prev version of this function
  }

----------


We also have tuples now which are nice. They are a bit different from arrays.
Tuples are designed to imbue meaning to the placement of each item in the
collection. As such, tuples can not be empty and they can not be updated to
change the amount of items they contain.

  {{ a, b }}

  CNS_.tuple([a, b]);

  CNS_.tuple = function (arr) {
    if (!arr.length) throw new Error('Tuples can not be empty.');
    Object.defineProperty(arr, 'CNS_isTuple', {enumerable: false, configurable: false, writable: false, value: CNS_._});
    return arr;
  };

  CNS_.get = function (item, collection) {
    return collection[item];
  };

  CNS_.update = function (key, val, collection) {
    var out;
    if (Array.isArray(collection)) {
      if (collection.CNS_isTuple === CNS_._) {
        if (collection.indexOf(key) === -1) throw new Error('Can not add extra items to tuples.');
        out = CNS_.tuple(collection.slice());
        out[key] = val;
      } else {
        out = collection.slice();
        out[key] = val;
      }
    } else {
      out = {};
      Object.keys(collection).forEach(function (k) { out[k] = collection[k] });
      out[key] = val;
    }
    return out;
  };

  CNS_.remove = function (item, collection) {
    var out;
    if (Array.isArray(collection)) {
      if (collection.CNS_isTuple === CNS_._) throw new Error('Can not remove items from tuples.');
      out = collection.slice();
      out.splice(item, 1);
    } else {
      out = {};
      Object.keys(collection).forEach(function (k) { k !== item && (out[k] = collection[k]) });
    }
    return out;
  };

We're removing the `def` keyword as well as the end keyword so we'll need a
way to combine functions for example:

  factorial 0 -> 1
  factorial n -> n * factorial n - 1

  const newBody   = [];
  const gather    = [];
  let   gathering = false;
  oldBody.forEach((item, index) => {
    if (item.type === 'FunctionDefinition') {
      if (gathering) { // need to check for whether the fn name is the same
        gather.push(item);
        if (!oldBody[index + 1] || oldBody[index + 1].type !== 'FunctionDefinition') {
          gathering = false;
          newBody.push(new FunctionDefinitionCollection(gather));
          gather = [];
        }
      } else {
        gathering = true;
        gather.push(item);
      }
    } else {
      newBody.push(item);
    }
  });

With exports, it would be really convenient to use all destructuring techniques.
However, it would also be really convenient to be able to export one form to
another form. Why not just use a nice semantic function for that?

  export {{ fn1, fn2, fn3 }} as Object

  module.exports = CNS_.exportObject(CNS_.tuple([fn1, fn2, fn3]));

  CNS._exportObject = function (tuple) {
    var out = {};
    tuple.forEach(function (item) {
      item.name & out[item.name] = item;
    });
    return out;
  };

"hello"
'hello'
`hello`
"
hello
"
'
hello
'
`
hello
`

/regex/gim

ATOM

@
@foo
foo
@foo
@foo.bar.baz

true
false
null
undefined

100
-100
100e6

!hello
!!hello

a >> b
a << b

2 + 4
7 lte 10

[]
[ ]
[

]
[


]
[ 1, 2, 3 ]
[
  1,
  2,
  3
]
[
  1, 2, 3
]
[
  1, 2, 3]
[ 1, 2, 3
]

{{ a, b, c }}
{}
{ }
{

}
{


}

{ a: 1, b: 2, c: 3 }
{
  a: 1,
  b: 2,
  c: 3
}
{
  a:1, b:2, c:3
}
{
  a: 1, b: 2, c: 3}
{ a: 1, b: 2, c: 3
}

<div className={ 2 + 2 } farts="sharts"></div>
<div
  className={ 2 + 2 }
  farts="sharts">
</div>
<div
  className={ 2 + 2 }
  farts="sharts"
></div>
<div
  className={ 2 + 2 }
  farts="sharts"
>
</div>
<div
  className={ 2 + 2 }
  farts="sharts">

    'Hello'

    <span className="name">'Bob'</span>

</div>

a >>= b >>= c

for x, y in list do x + y
for x, y in [1, 2, 3] do /fart/.test x onlyif x == y

if x == y then x + y
if x == y then x + y else x - y

export {{ factorial, schmactorial }}
export { factorial: factorial, schmactorial: schmactorial }
export [ factorial, schmactorial ]

import 'factorial'
import factorial from 'factorial'
import [ factorial, schmactorial ] from 'factorial'
import { factorial, schmactorial } from 'factorial'
import {{ factorial, schmactorial }} from 'factorial'
import { factorial: f, schmactorial: s } from 'factorial'
import [ fn1 | restFns ] from 'factorial'
import [ leadFns || lastFn ] from 'factorial'

a = b
[a, b] = c
{a, b} = c
{{a, b}} = c
{a:b, c:d} = e
[a | b] = c
[a || b] = c
foo =

  'bar'

perform()
perform(hard, task)
perform _
perform task
perform hard, task

when
  'bar' -> x + y
  true  -> 'hello'

when
  'bar'
    x + y
  true
    'hello'

caseof foo
  'bar' -> x + y
  'baz' -> a + b
  default -> c + d

caseof foo
  'bar'
    x + y
    1 + 2
  'baz'
    a + b
  default
    c + d

try

  perform 'task'

catch err
  perform 'other task'

fn _ => x + y

fn(x, y) =>

  x + y

fn =>
  x + y

foo x => x * 2

bar _ => x * 2

stringify val ::=>
  when
    type val is 'object' -> Json.stringify val # change Json to JSON
    true                 -> val.toString _

# The next 2 fns should merge into a polymorph.
foo 0 => 1

# This one should be included with the one above because
# they have the same name.
foo x => 2

receive match
  {{ FACTORIAL, num }} => reply {{ OK, factorial num }}
  _                    => {{ ERR, 'Unknown command received' }}

apply fn => x + 2, [2]

apply (fn => x + 3), [3]

apply (fn =>
  x + 4
), [4]

apply fn => _

x / y

x % y

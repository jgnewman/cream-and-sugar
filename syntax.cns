###
New Syntax
###

up() =>
  spawn fn =>

    # Define the factorial function so that we can actually calculate them.
    factorial 0 => 1
    factorial n where n lt 1 => 1
    factorial n => n * factorial n - 1

    # When we receive a message, pattern match it to figure out what to do.
    receive match
      {{ FACTORIAL, num }} => reply {{ OK, factorial num }}
      _                    => {{ ERR, 'Unknown command received' }}



stringify val =>
  when
    typeof val is 'object' -> Json.stringify val # change Json to JSON
    true                   -> val.toString _


nodes.HtmlNode.compile = fn =>
  name = maybeQuote (this.openTag.compile true)
  body = if this.body then compileBody this.body else ''

  close =
    when
      !this.selfClosing -> this.closeTag.replace /^\<\\s*|\s*\>$/g, ''
      this.selfClosing  -> null

  attrs = compileAttrs this.attrs
  this.shared.lib.add 'createElement'

  when
    no this.selfClosing and close isnt name.replace /[\'\"\`]/g, ''
      die this, `Closing tag "${close}" does not match opening tag ${name}.`

  `CNS_SYSTEM.createElement(${name}, {${attrs}}, [${if body then '\n' + body + '\n' else ''}])`

# function definitions
fnname() =>
  perform 'task'

fn =>
  perform 'task'

fnname 0 => perform 'task'
fnname 1 => perform 'other test'
fnname 2 where 2 isnt 4 => perform 'last task'

fn => _

# tuples
{{ item, item, item }}

# objects
{ key: val, key: val, key: val }

# arrays
[ item, item, item ]

# atoms
ALLCAPS

# conditions
when
  condition true  -> perform 'task'
  condition false -> perform 'other task'

when
  condition true
    perform 'task'
  condition false
    perform 'other task'

caseof myBoolean
  true    -> perform 'task'
  false   -> perform 'other task'
  default -> perform 'third task'

caseof myBoolean
  true
    perform 'task'
  false
    perform 'other task'
  default
    perform 'third task'

# Qualifiers
if some 'condition' then perform 'task'
if some 'condition' then perform 'task' else dont 'perform task'

# comprehensions
for x, i in list do perform x, i
for x, i in list do perform x, i onlyif i % 2 == 0

# destructuring
obj = { a: 1, b: 2 }
arr = [ 'a', 'b' ]
tup = {{ A, 1 }}

{ a: destA, b: destB } = obj
{ a, b } = obj
[ a, b ] = arr
{{ a, b }} = tup
[ head | tail ] = arr
[ lead || last ] = arr

# cons
1 >> [2, 3]

# back cons
[1, 2] << 3

# piping
someValue >>= curried 'fn' >>= furried 'cn'

# exports
export {{ factorial, schmactorial }}
export { factorial: factorial, schmactorial: schmactorial }
export [ factorial, schmactorial ]

# imports
import {{ factorial, schmactorial }} from 'factorial'
import { factorial, schmactorial } from 'factorial'
import [ factorial, schmactorial ] from 'factorial'
import { factorial: f, schmactorial: s } from 'factorial'
import [ fn1 | restFns ] from 'factorial'
import [ leadFns || lastFn ] from 'factorial'

# trycatch
try
  x + y
catch err
  a + b

incase x + y throws err do a + b
